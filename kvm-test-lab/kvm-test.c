#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <linux/kvm.h>
#include <memory.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define CR0_PE 1
#define CR0_MP (1 << 1)
#define CR0_EM (1 << 2)
#define CR0_TS (1 << 3)
#define CR0_ET (1 << 4)
#define CR0_NE (1 << 5)
#define CR0_WP (1 << 16)
#define CR0_AM (1 << 18)
#define CR0_NW (1 << 29)
#define CR0_CD (1 << 30)
#define CR0_PG (1 << 31)

#define CR4_VME 1
#define CR4_PVI (1 << 1)
#define CR4_TSD (1 << 2)
#define CR4_DE (1 << 3)
#define CR4_PSE (1 << 4)
#define CR4_PAE (1 << 5)
#define CR4_MCE (1 << 6)
#define CR4_PGE (1 << 7)
#define CR4_PCE (1 << 8)
#define CR4_OSFXSR (1 << 8)
#define CR4_OSXMMEXCPT (1 << 10)
#define CR4_UMIP (1 << 11)
#define CR4_VMXE (1 << 13)
#define CR4_SMXE (1 << 14)
#define CR4_FSGSBASE (1 << 16)
#define CR4_PCIDE (1 << 17)
#define CR4_OSXSAVE (1 << 18)
#define CR4_SMEP (1 << 20)
#define CR4_SMAP (1 << 21)
#define CR4_PKE (1 << 22)

#define EFER_SCE 1
#define EFER_LME (1 << 8)
#define EFER_LMA (1 << 10)
#define EFER_NXE (1 << 11)
#define EFER_SVME (1 << 12)
#define EFER_LMSLE (1 << 13)
#define EFER_FFXSR (1 << 14)
#define EFER_TCE (1 << 15)

#define PDE32_PRESENT 1
#define PDE32_RW (1 << 1)
#define PDE32_USER (1 << 2)
#define PDE32_PS (1 << 7)

#define PDE64_PRESENT 1
#define PDE64_RW (1 << 1)
#define PDE64_USER (1 << 2)
#define PDE64_ACCESSED (1 << 5)
#define PDE64_DIRTY (1 << 6)
#define PDE64_PS (1 << 7)
#define PDE64_G (1 << 8)

struct tss64 {
  uint32_t reserved0;
  uint64_t rsp[3];
  uint64_t reserved1;
  uint64_t ist[7];
  uint64_t reserved2;
  uint32_t reserved3;
  uint32_t io_bitmap;
} __attribute__((packed));

static void fill_segment_descriptor(uint64_t* dt, uint64_t* lt,
                                    struct kvm_segment* seg)
{
  uint16_t index = seg->selector >> 3;
  uint32_t limit = seg->g ? seg->limit >> 12 : seg->limit;
  uint64_t sd =
      (limit & 0xffff)               /* Limit bits 0:15 */
      | (seg->base & 0xffffff) << 16 /* Base bits 0:23 */
      | (uint64_t)seg->type << 40 |
      (uint64_t)seg->s << 44     /* system or code/data */
      | (uint64_t)seg->dpl << 45 /* Privilege level */
      | (uint64_t)seg->present << 47 |
      (limit & 0xf0000ULL) << 48 /* Limit bits 16:19 */
      | (uint64_t)seg->avl << 52 /* Available for system software */
      | (uint64_t)seg->l << 53   /* 64-bit code segment */
      | (uint64_t)seg->db << 54  /* 16/32-bit segment */
      | (uint64_t)seg->g << 55   /* 4KB granularity */
      | (seg->base & 0xff000000ULL) << 56; /* Base bits 24:31 */
  (dt[index] = sd);
}

const char kvm_asm64_init_vm[] =
    "\x0f\x20\xc0\x0d\x00\x00\x00\x80\x0f\x22\xc0\xea\xde\xc0\xad\x0b"
    "\x48\x00\x48\xc7\xc0\x80\x00\x00\x00\x0f\x00\xd8\x48\xc7\xc1\x3a"
    "\x00\x00\x00\x0f\x32\x48\x83\xc8\x05\x0f\x30\x0f\x20\xe0\x48\x0d"
    "\x00\x20\x00\x00\x0f\x22\xe0\x48\xc7\xc1\x80\x04\x00\x00\x0f\x32"
    "\x48\xc7\xc2\x00\x60\x00\x00\x89\x02\x48\xc7\xc2\x00\x70\x00\x00"
    "\x89\x02\x48\xc7\xc0\x00\x5f\x00\x00\xf3\x0f\xc7\x30\x48\xc7\xc0"
    "\x08\x5f\x00\x00\x66\x0f\xc7\x30\x0f\xc7\x30\x48\xc7\xc1\x81\x04"
    "\x00\x00\x0f\x32\x48\x83\xc8\x3f\x48\x21\xd0\x48\xc7\xc2\x00\x40"
    "\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x02\x40\x00\x00\x48\xc7\xc0\x84"
    "\x9e\x99\x61\x0f\x79\xd0\x48\xc7\xc2\x1e\x40\x00\x00\x48\xc7\xc0"
    "\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc1\x83\x04\x00\x00\x0f\x32"
    "\x48\x0d\xff\x6f\x03\x00\x48\x21\xd0\x48\xc7\xc2\x0c\x40\x00\x00"
    "\x0f\x79\xd0\x48\xc7\xc1\x84\x04\x00\x00\x0f\x32\x48\x0d\xff\x13"
    "\x00\x00\x48\x21\xd0\x48\xc7\xc2\x12\x40\x00\x00\x0f\x79\xd0\x48"
    "\xc7\xc2\x04\x2c\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0"
    "\x48\xc7\xc2\x00\x28\x00\x00\x48\xc7\xc0\xff\xff\xff\xff\x0f\x79"
    "\xd0\x48\xc7\xc2\x02\x0c\x00\x00\x48\xc7\xc0\x48\x00\x00\x00\x0f"
    "\x79\xd0\x48\xc7\xc0\x30\x00\x00\x00\x48\xc7\xc2\x00\x0c\x00\x00"
    "\x0f\x79\xd0\x48\xc7\xc2\x04\x0c\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x06\x0c\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x08\x0c\x00\x00\x0f\x79"
    "\xd0\x48\xc7\xc2\x0a\x0c\x00\x00\x0f\x79\xd0\x48\xc7\xc0\x80\x00"
    "\x00\x00\x48\xc7\xc2\x0c\x0c\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x02"
    "\x2c\x00\x00\x48\xc7\xc0\x00\x05\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x00\x4c\x00\x00\x48\xc7\xc0\x48\x00\x00\x00\x0f\x79\xd0\x48\xc7"
    "\xc2\x10\x6c\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48"
    "\xc7\xc2\x12\x6c\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0"
    "\x0f\x20\xc0\x48\xc7\xc2\x00\x6c\x00\x00\x48\x89\xc0\x0f\x79\xd0"
    "\x0f\x20\xd8\x48\xc7\xc2\x02\x6c\x00\x00\x48\x89\xc0\x0f\x79\xd0"
    "\x0f\x20\xe0\x48\xc7\xc2\x04\x6c\x00\x00\x48\x89\xc0\x0f\x79\xd0"
    "\x48\xc7\xc2\x06\x6c\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79"
    "\xd0\x48\xc7\xc2\x08\x6c\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f"
    "\x79\xd0\x48\xc7\xc2\x0a\x6c\x00\x00\x48\xc7\xc0\x00\x09\x00\x00"
    "\x0f\x79\xd0\x48\xc7\xc2\x0c\x6c\x00\x00\x48\xc7\xc0\x00\x10\x00"
    "\x00\x0f\x79\xd0\x48\xc7\xc2\x0e\x6c\x00\x00\x48\xc7\xc0\x00\x0b"
    "\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x14\x6c\x00\x00\x48\xc7\xc0\x00"
    "\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x16\x6c\x00\x00\x48\x8b\x04"
    "\x25\x10\x5f\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x00\x00\x00\x00\x48"
    "\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x02\x00\x00\x00"
    "\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x00\x20\x00"
    "\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x02\x20"
    "\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x04"
    "\x20\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x06\x20\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7"
    "\xc1\x77\x02\x00\x00\x0f\x32\x48\xc1\xe2\x20\x48\x09\xd0\x48\xc7"
    "\xc2\x00\x2c\x00\x00\x48\x89\xc0\x0f\x79\xd0\x48\xc7\xc2\x04\x40"
    "\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0a"
    "\x40\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x0e\x40\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7"
    "\xc2\x10\x40\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48"
    "\xc7\xc2\x16\x40\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0"
    "\x48\xc7\xc2\x14\x40\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79"
    "\xd0\x48\xc7\xc2\x00\x60\x00\x00\x48\xc7\xc0\xff\xff\xff\xff\x0f"
    "\x79\xd0\x48\xc7\xc2\x02\x60\x00\x00\x48\xc7\xc0\xff\xff\xff\xff"
    "\x0f\x79\xd0\x48\xc7\xc2\x1c\x20\x00\x00\x48\xc7\xc0\x00\x00\x00"
    "\x00\x0f\x79\xd0\x48\xc7\xc2\x1e\x20\x00\x00\x48\xc7\xc0\x00\x00"
    "\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x20\x20\x00\x00\x48\xc7\xc0\x00"
    "\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x22\x20\x00\x00\x48\xc7\xc0"
    "\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x00\x08\x00\x00\x48\xc7"
    "\xc0\x30\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x02\x08\x00\x00\x48"
    "\xc7\xc0\x48\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x04\x08\x00\x00"
    "\x48\xc7\xc0\x30\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x06\x08\x00"
    "\x00\x48\xc7\xc0\x30\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x08\x08"
    "\x00\x00\x48\xc7\xc0\x30\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0a"
    "\x08\x00\x00\x48\xc7\xc0\x30\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x0c\x08\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7"
    "\xc2\x0e\x08\x00\x00\x48\xc7\xc0\x80\x00\x00\x00\x0f\x79\xd0\x48"
    "\xc7\xc2\x12\x68\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0"
    "\x48\xc7\xc2\x14\x68\x00\x00\x48\xc7\xc0\x00\x09\x00\x00\x0f\x79"
    "\xd0\x48\xc7\xc2\x16\x68\x00\x00\x48\xc7\xc0\x00\x10\x00\x00\x0f"
    "\x79\xd0\x48\xc7\xc2\x18\x68\x00\x00\x48\xc7\xc0\x00\x0b\x00\x00"
    "\x0f\x79\xd0\x48\xc7\xc2\x00\x48\x00\x00\x48\xc7\xc0\xff\xff\x0f"
    "\x00\x0f\x79\xd0\x48\xc7\xc2\x02\x48\x00\x00\x48\xc7\xc0\xff\xff"
    "\x0f\x00\x0f\x79\xd0\x48\xc7\xc2\x04\x48\x00\x00\x48\xc7\xc0\xff"
    "\xff\x0f\x00\x0f\x79\xd0\x48\xc7\xc2\x06\x48\x00\x00\x48\xc7\xc0"
    "\xff\xff\x0f\x00\x0f\x79\xd0\x48\xc7\xc2\x08\x48\x00\x00\x48\xc7"
    "\xc0\xff\xff\x0f\x00\x0f\x79\xd0\x48\xc7\xc2\x0a\x48\x00\x00\x48"
    "\xc7\xc0\xff\xff\x0f\x00\x0f\x79\xd0\x48\xc7\xc2\x0c\x48\x00\x00"
    "\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0e\x48\x00"
    "\x00\x48\xc7\xc0\xff\x1f\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x10\x48"
    "\x00\x00\x48\xc7\xc0\xff\x1f\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x12"
    "\x48\x00\x00\x48\xc7\xc0\xff\x1f\x00\x00\x0f\x79\xd0\x48\xc7\xc2"
    "\x14\x48\x00\x00\x48\xc7\xc0\x93\x40\x00\x00\x0f\x79\xd0\x48\xc7"
    "\xc2\x16\x48\x00\x00\x48\xc7\xc0\x9b\x20\x00\x00\x0f\x79\xd0\x48"
    "\xc7\xc2\x18\x48\x00\x00\x48\xc7\xc0\x93\x40\x00\x00\x0f\x79\xd0"
    "\x48\xc7\xc2\x1a\x48\x00\x00\x48\xc7\xc0\x93\x40\x00\x00\x0f\x79"
    "\xd0\x48\xc7\xc2\x1c\x48\x00\x00\x48\xc7\xc0\x93\x40\x00\x00\x0f"
    "\x79\xd0\x48\xc7\xc2\x1e\x48\x00\x00\x48\xc7\xc0\x93\x40\x00\x00"
    "\x0f\x79\xd0\x48\xc7\xc2\x20\x48\x00\x00\x48\xc7\xc0\x82\x00\x00"
    "\x00\x0f\x79\xd0\x48\xc7\xc2\x22\x48\x00\x00\x48\xc7\xc0\x8b\x00"
    "\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x1c\x68\x00\x00\x48\xc7\xc0\x00"
    "\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x1e\x68\x00\x00\x48\xc7\xc0"
    "\x00\x91\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x20\x68\x00\x00\x48\xc7"
    "\xc0\x02\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x06\x28\x00\x00\x48"
    "\xc7\xc0\x00\x05\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0a\x28\x00\x00"
    "\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0c\x28\x00"
    "\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x0e\x28"
    "\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x48\xc7\xc2\x10"
    "\x28\x00\x00\x48\xc7\xc0\x00\x00\x00\x00\x0f\x79\xd0\x0f\x20\xc0"
    "\x48\xc7\xc2\x00\x68\x00\x00\x48\x89\xc0\x0f\x79\xd0\x0f\x20\xd8"
    "\x48\xc7\xc2\x02\x68\x00\x00\x48\x89\xc0\x0f\x79\xd0\x0f\x20\xe0"
    "\x48\xc7\xc2\x04\x68\x00\x00\x48\x89\xc0\x0f\x79\xd0\x0f\x01\xc2"
    "\x48\xc7\xc2\x00\x44\x00\x00\x0f\x78\xd0\xf4";

const char kvm_asm64_vm_exit[] =
    "\xf4\x48\xc7\xc3\x00\x44\x00\x00\x0f\x78\xda\x48\xc7\xc3\x02\x44"
    "\x00\x00\x0f\x78\xd9\x48\xc7\xc0\x00\x64\x00\x00\x0f\x78\xc0\x48"
    "\xc7\xc3\x1e\x68\x00\x00\x0f\x78\xdb\xf4";

void test()
{
  int kvmfd = open("/dev/kvm", O_RDWR);
  int vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);
  int cpufd = ioctl(vmfd, KVM_CREATE_VCPU, 0);

  const uintptr_t guest_mem_size = 64 << 10;
  const uintptr_t host_mem =
      (uintptr_t)mmap(0, guest_mem_size, PROT_READ | PROT_WRITE,
                      MAP_PRIVATE | MAP_ANON, -1, 0);

  struct kvm_userspace_memory_region memreg;
  memreg.slot = 0;
  memreg.flags = 0;
  memreg.guest_phys_addr = 0;
  memreg.memory_size = guest_mem_size;
  memreg.userspace_addr = host_mem;
  ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &memreg);

  struct kvm_sregs sregs;
  ioctl(cpufd, KVM_GET_SREGS, &sregs);

  sregs.cr0 = 0;
  sregs.cr4 = 0;
  sregs.efer = 0;

  sregs.gdt.base = 0x1000;
  sregs.gdt.limit = 24 * sizeof(uint64_t) - 1;
  uint64_t* gdt = (uint64_t*)(host_mem + sregs.gdt.base);
  uint64_t* ldt = gdt;

  struct kvm_segment seg_cs16;
  seg_cs16.selector = (1 << 3);
  seg_cs16.type = 11;
  seg_cs16.base = 0;
  seg_cs16.limit = 0xfffff;
  seg_cs16.present = 1;
  seg_cs16.dpl = 0;
  seg_cs16.s = 1;
  seg_cs16.g = 0;
  seg_cs16.db = 0;
  seg_cs16.l = 0;
  fill_segment_descriptor(gdt, ldt, &seg_cs16);

  struct kvm_segment seg_ds16 = seg_cs16;
  seg_ds16.selector = (2 << 3);
  seg_ds16.type = 3;
  fill_segment_descriptor(gdt, ldt, &seg_ds16);

  struct kvm_segment seg_cs16_cpl3 = seg_cs16;
  seg_cs16_cpl3.selector = (3 << 3) + 3;
  seg_cs16_cpl3.dpl = 3;
  fill_segment_descriptor(gdt, ldt, &seg_cs16_cpl3);

  struct kvm_segment seg_ds16_cpl3 = seg_ds16;
  seg_ds16_cpl3.selector = (4 << 3) + 3;
  seg_ds16_cpl3.dpl = 3;
  fill_segment_descriptor(gdt, ldt, &seg_ds16_cpl3);

  struct kvm_segment seg_cs32 = seg_cs16;
  seg_cs32.selector = (5 << 3);
  seg_cs32.db = 1;
  fill_segment_descriptor(gdt, ldt, &seg_cs32);

  struct kvm_segment seg_ds32 = seg_ds16;
  seg_ds32.selector = (6 << 3);
  seg_ds32.db = 1;
  fill_segment_descriptor(gdt, ldt, &seg_ds32);

  struct kvm_segment seg_cs32_cpl3 = seg_cs32;
  seg_cs32_cpl3.selector = (7 << 3) + 3;
  seg_cs32_cpl3.dpl = 3;
  fill_segment_descriptor(gdt, ldt, &seg_cs32_cpl3);

  struct kvm_segment seg_ds32_cpl3 = seg_ds32;
  seg_ds32_cpl3.selector = (8 << 3) + 3;
  seg_ds32_cpl3.dpl = 3;
  fill_segment_descriptor(gdt, ldt, &seg_ds32_cpl3);

  struct kvm_segment seg_cs64 = seg_cs16;
  seg_cs64.selector = (9 << 3);
  seg_cs64.l = 1;
  fill_segment_descriptor(gdt, ldt, &seg_cs64);

  struct kvm_segment seg_cs64_cpl3 = seg_cs64;
  seg_cs64_cpl3.selector = (10 << 3) + 3;
  seg_cs64_cpl3.dpl = 3;
  fill_segment_descriptor(gdt, ldt, &seg_cs64_cpl3);

  const uintptr_t task_base = 0x500;
  struct kvm_segment seg_tss_32;
  seg_tss_32.selector = (11 << 3);
  seg_tss_32.type = 9;
  seg_tss_32.base = task_base;
  seg_tss_32.limit = 0xff;
  seg_tss_32.present = 1;
  seg_tss_32.dpl = 0;
  seg_tss_32.s = 0;
  seg_tss_32.g = 0;
  seg_tss_32.db = 0;
  seg_tss_32.l = 0;
  fill_segment_descriptor(gdt, ldt, &seg_tss_32);

  struct kvm_segment seg_tss_64 = seg_tss_32;
  seg_tss_64.selector = (16 << 3);
  seg_tss_64.base = task_base + 0x400;
  seg_tss_64.limit = 0x1ff;
  fill_segment_descriptor(gdt, ldt, &seg_tss_64);
  gdt[16 + 1] = 0;

  struct tss64* tss = (struct tss64*)(host_mem + seg_tss_64.base);
  memset(tss, 0, sizeof(*tss));
  tss->rsp[0] = 0x100;
  tss->rsp[1] = 0x100;
  tss->rsp[2] = 0x100;
  tss->io_bitmap = offsetof(struct tss64, io_bitmap);

  sregs.efer |= EFER_LME;
  sregs.cr0 |= CR0_PE;

  sregs.idt.base = task_base + 0x600;
  sregs.ldt.limit = 0x1ff;
  uint64_t* idt = (uint64_t*)(host_mem + sregs.idt.base);
  int i;
  for (i = 0; i < 32; i++) {
    idt[i * 2] = (0x600 + i) | (seg_cs64.selector << 16) |
                 (14ull << 40) | (1ull << 47);
    idt[i * 2 + 1] = 0;

    (*((char*)host_mem + 0x600 + i) = 0xf4); // hlt
  }

  sregs.cs = seg_cs32;
  sregs.ds = sregs.es = sregs.fs = sregs.gs = sregs.ss = seg_ds32;

  uint64_t pml4_addr = 0x3000;
  uint64_t* pml4 = (uint64_t*)(host_mem + 0x3000);

  uint64_t pdpt_addr = 0x4000;
  uint64_t* pdpt = (uint64_t*)(host_mem + 0x4000);

  uint64_t pd_addr = 0x5000;
  uint64_t* pd = (uint64_t*)(host_mem + 0x5000);

  (pml4[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr);
  (pdpt[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr);
  (pd[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS);

  sregs.cr3 = pml4_addr;
  sregs.cr4 |= CR4_PAE;

  sregs.cr0 |= CR0_NE;

  char buf[16 << 10];
  memset(buf, 0, sizeof(buf));
  struct kvm_cpuid2* cpuid = (struct kvm_cpuid2*)buf;
  cpuid->nent = 128;
  ioctl(kvmfd, KVM_GET_SUPPORTED_CPUID, cpuid);
  ioctl(cpufd, KVM_SET_CPUID2, cpuid);

  (*((uint64_t*)(host_mem + 0x5f00)) = 0x6000);
  (*((uint64_t*)(host_mem + 0x5f08)) = 0x7000);
  (memcpy((char*)host_mem + 0x9000, kvm_asm64_vm_exit,
          sizeof(kvm_asm64_vm_exit) - 1));
  (*((uint64_t*)(host_mem + 0x5f10)) = 0x9000);
  (*((char*)host_mem + 0x9100) = 0xf4); // hlt

  ioctl(cpufd, KVM_SET_SREGS, &sregs);

  memcpy((char*)host_mem, kvm_asm64_init_vm,
         sizeof(kvm_asm64_init_vm) - 1);
  void* jmp_off = memmem((char*)host_mem, sizeof(kvm_asm64_init_vm) - 1,
                         "\xde\xc0\xad\x0b", 4);
  if (jmp_off)
    *((uint32_t*)jmp_off) = ((char*)jmp_off - (char*)host_mem) + 6;
  (*((char*)host_mem + sizeof(kvm_asm64_init_vm) - 1) = 0xf4); // hlt

  struct kvm_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.rflags = 2;
  regs.rip = 0;
  regs.rsp = 0x200;
  ioctl(cpufd, KVM_SET_REGS, &regs);
  ioctl(cpufd, KVM_RUN, 0);
}


int main()
{
  int i;
  for (i = 0; i < 1; i++) {
    if (fork())
      continue;
    for (;;) {
      int pid = fork();
      if (pid < 0)
        exit(0);
      if (pid == 0) {
	printg();
        exit(0);
      }
      int status = 0;
      while (waitpid(-1, &status, __WALL) != pid) {
      }
    }
  }
  sleep(100000);
  return 0;
}
